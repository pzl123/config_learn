# 全局变量
[global]

# 等于true时（默认），zlog_init函数会严格检查所有格式和规则，false时则忽略；
strict init = true

# 当写日志的次数达到10M次会调用zlog_reload()函数进行重载，默认为0也即关闭
reload conf period = 10M

# zlog在堆上为每个线程申请缓存，zlog_init函数申请，如果单条日志长度大于缓存会自动扩充直到最大值max；
# 如果max = 0，每次扩充为原先的两倍，直到这个进程用完所有的内存为止；另外，数值不区分大小写。
buffer min = 1024 	
buffer max = 2MB

# 指定一个锁文件，用来保证多进程情况下日志安全转档，zlog_init函数需要用户具备它的rw权限；
# 如果使用默认值self，则不创建任何锁文件，用配置文件作为锁文件，也即本文件；
# rotate lock file = /tmp/zlog.lock
rotate lock file = self

# 默认的日志格式，选项含义如下：
# %c	分类名
# %d()	日志的时间，内部的%F代表%Y-%m-%d，%T时间，%l为12小时制，%m毫秒，%u微秒
# %D() 	日志的时间，%m/%d/%y格式
# %E() 	获取环境变量的值 	
# %F 	源代码文件名，来源__FILE__，部分编译器会生成绝对路径
# %f 	源代码文件名，仅文件名，不带路径
# %L 	源代码行号
# %m 	用户日志
# %n 	换行符
# %p 	进程ID，来源于getpid()
# %t 	16进制的线程ID：0x%x，来源于pthread_self()
# %T 	长整型的线程ID：0xlu
# %U 	调用函数名，来源于__func__(C99)或者__FUNCTION__(gcc)
# %V 	大写日志级别
# %v 	小写日志级别
# %-6 	对齐符号，占6个字符宽度，符号“-”代表左对齐
# %ms 	毫秒，3位数字字符串，取自gettimeofday
# %us 	微秒，6位数字字符串，取自gettimeofday
default format = "%d(%F %T.%l) %-6V (%c:%F:%L) - %m%n"
# default format = "%d(%F %T).%us %-6V (%c:%F:%L) - %m%n"

# 指定了创建的日志文件默认的访问权限
file perms = 600

# 每条规则写了1K次之后调用fsync让系统把数据写到硬盘
fsync period = 1K


# 自定义一个打印级别，范围在[1,253]，值越大越重要，格式如下（syslog level不写默认为LOG_DEBUG）：
#   (level string) = (level int), (syslog level, optional)
# 系统自带的如下：
#   DEBUG = 20,    LOG_DEBUG
#   INFO = 40,     LOG_INFO
#   NOTICE = 60,   LOG_NOTICE
#   WARN = 80,     LOG_WARNING
#   ERROR = 100,   LOG_ERR
#   FATAL = 120,   LOG_ALERT
#   UNKNOWN = 254, LOG_ERR
[levels]
TRACE = 10
CRIT = 130, LOG_CRIT


# 描述输出日志的格式，比如是否带有时间戳，是否包含文件位置信息等，选项见上方“default format”
[formats]
simple = "%m%n"
normal = "%d(%F %T.%l) %m%n"


# 把类别、级别、输出文件、格式进行组合，也即决定日志是否输出，输出到哪里，以怎样的格式输出
[rules]

# 匹配类别为“default”，所有日志级别都以“simple”格式输出到标准输出
default.*       >stdout; simple

# 文件转档：(将日志文件按照大小、日期来切分)
# 	选项“-”后接文件路径，代表打开同步IO选项，即以O_SYNC打开，等硬盘写完才返回；
# 	"%12.2E(HOME)/log/%c.log"代表正在生成的日志的文件名；
# 	1MB代表文件达到该尺寸之后开始转档;
# 	12代表保留多少个存档文件（0代表不删除任何一个）；
# 	"%E(HOME)/log/%c.%D(%F) #2r #3s.log"代表转档的文件名格式，必须包含#r或者#s（一个即可，中间数字代表数值的长度）：
# 		#r是Rolling的缩写，后缀小的文件较新；
# 		#s是Sequence的缩写，后缀大的文件较新；
# 	simple代表输出的日志格式
*.*         -"%12.2E(HOME)/log/%c.log", \
            1MB * 12 ~ "%E(HOME)/log/%c.%D(%F) #2r #3s.log"; \
            simple
# 上面示例不能正常使用，正常使用的示例：
# *.*     -"%E(PWD)/log/%c.log", 1MB * 12 ~ "%E(PWD)/log/%c.%D(%F).#2s.log"; normal

# 匹配类别为“my”及“my_xx”...级别>=INFO的输出到标准错误中
my_.INFO        >stderr;

# 匹配类别为“my_cat”，级别!=ERROR输出到文件aa.log中
# my_cat.!ERROR       "aa.log"
my_cat.*       >stdout; simple

# 匹配类别为“my_dog”，级别==DEBUG的以格式“simple”输出到syslog，LOG_LOCAL[0-7]必填
my_dog.=DEBUG       >syslog, LOG_LOCAL0; simple

# 以管道输出给后面的/usr/bin/cronolog（这里只是以cronolog按天分割日志为例）
# zlog_init函数调用popen("/usr/bin/cronolog /www/logs/example_%Y%m%d.log", "w");
my_dog.=DEBUG       | /usr/bin/cronolog /www/logs/example_%Y%m%d.log ; normal

# 匹配类别为“my_mice”，符号“$”代表自定义输出：
# 	$record_func代表自定义的名称，需程序调用zlog_set_record()将record_func与自定义的函数“绑定”；
# 	"record_path%c"就是普通的stdout/stderr、文件等。
my_mice.*       $record_func , "record_path%c"; normal
